<!-- 每天一个知识点 -->

## HTML

## CSS
### 1.1 visibility=hidden, opacity=0，display:none 区别？

> opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些 事件，如 click 事件，那么点击该区域，也能触发点击事件的 visibility=hidden，该元素 隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 display=none， 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。

### 1.2 CSS中link和@import的区别是什么？

> - `link`属于HTML标签，而`@import`是CSS提供的
> -  页面被加载的时，`link`会同时被加载，而`@import`被引用的CSS会等到引用它的 CSS文件被加
载完再加载
> - `import`只在IE5以上才能识别，而`link`是HTML标签，无兼容问题
> - `link`方式的样式的权重 高于`@import`的权重
## JS

### 1.箭头函数和 function 的区别.

> 箭头函数根本就没有绑定自己的 `this`，在箭头函数中调用 `this` 时，仅仅是简单的沿着作 用域链向上寻找，找到最近的一个 `this` 拿来使用

### 2.什么是防抖和节流？有什么区别？如何实现？

> 函数防抖(`debounce`):在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。（函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。）

```javascript
function debounce(fun, delay) {
  return function (args) {
    let that = this;
    let _args = args;
    clearTimeout(fun.id);
    fun.id = setTimeout(function () {
      fun.call(that, _args);
    }, delay);
  };
}
```

> 函数节流(`throttle`)：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。（函数节流就是 `fps` 游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。）

```javascript
function throttle(fun, delay) {
  let last, deferTimer;
  return function (args) {
    let that = this;
    let _args = arguments;
    let now = +new Date();
    if (last && now < last + delay) {
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        fun.apply(that, _args);
      }, delay);
    } else {
      last = now;
      fun.apply(that, _args);
    }
  };
}
```

> - 使用场景：
>
> > - `debounce`
>
> > > - `search` 搜索联想，用户在不断输入值时，用防抖来节约请求资源。
> > >
> > > - `window` 触发 `resize` 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
> >
> > - `throttle`
>
> > > - 鼠标不断点击触发，`mousedown`(单位时间内只触发一次)
> > > - 监听滚动事件，比如是否滑到底部自动加载更多，用 `throttle` 来判断

### 3.['1', '2', '3'].map(parseInt) what & why ?

> 第一眼看到这个题目的时候，脑海跳出的答案是 `[1, 2, 3]`，但是真正的答案是`[1, NaN, NaN]`。 首先让我们回顾一下，`map` 函数的第一个参数 `callback`。这个 `callback` 一共可以 接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该 元素的索引。 `arr.map(callback: (value: T, index: number, array: T[]) => U, thisArg?: any)` 而 `parseInt` 则是用来解析字符串的，使字符串成为指定基数的整数。接收两个 参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。 `parseInt(string, radix)` 了解这两个函数后，我们可以模拟一下运行情况 `parseInt('1', 0) //radix` 为 `0` 时，且 `string` 参数不以 `0x` 和 `0` 开头时， 按照 `10` 为基数处理。这个时候返回 `1parseInt('2', 1)` //基数为 1（1 进制）表示的数中，最大值小于 `2`，所以无法解析，返回 `NaNparseInt('3', 2) //基数 为 2（2 进制）`表示的数中，最大值小于 3，所以无法解析，返回 `NaN`

### 4.[Object.is()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 与原来的比较操作符 “===”、“==” 的区别？

> - 两等号判等，会在比较时进行类型转换；
> - 三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回`false`）；
> - `Object.is` 在三等号判等的基础上特别处理了 `NaN `、`-0 `和 `+0 `，保证 `-0` 和 `+0` 不再相同，但
`Object.is(NaN, NaN)` 会返回 `true`;
> - `Object.is` 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。

## 框架

### VUE

#### 1.为什么要在列表组件中写 key，其作用是什么？

> `key` 是给每一个 `vnode` 的唯一 `id`,可以依靠 `key`,更准确,更快的拿到 `oldVnode` 中对 应的 `vnode` 节点

#### 2.v-if 和 v-show 使用场景

> - `v-if` 是惰性的条件渲染，直到渲染条件为真时才渲染内容。
> - `v-show` 会先把内容渲染出来，基于 `css` 的 `display` 属性进行切换

#### 3.computed 和 watch 区分使用场景。

> - `Computed` 是计算属性，依赖其他属性值，且有缓存，只有当他依赖的属性值发生变化时，下一次获取 `computed` 值时才会重新计算。适用于数据计算。
> - `Watch` 是数据的监听回调，当数据变化时会执行回调。适用于数据变化时执行异步操作或开销较大的操作。

#### 4.data 为什么是一个方法而不是对象？

> 因为组件可能被复用为多个实例，如果是对象，那么所有实例会共享一份 data，显然是不行的。而 funtion 会开辟一份独立的内存空间，实例之间不会互相影响。

#### 5.Vuex 持久化？

> - 存放在 `localStorage` 或者 `sessionStorage` 里面，进入页面时判断是否丢失，丢失再去 `localStorage` 或者 `sessionStorage` 里面取；
> - 在 `app.vue` 根组件的 `created` 里面判断是否丢失，在进行上面的操作；

#### 6.说一下什么是Vue中的数据双向绑定，以及原理.

> - `vue`是一个mvvm框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是vue的精髓之处了。**值得注意的是，**我们所说的数据双向绑定，一定是对于UI控件来说的，非UI控件不会涉及到数据双向绑定。
> - 原理
> > - `vue` 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 `Object.defineProperty()` 来劫持各个属性的 `setter`，`getter`，在数据变动时发布消息给订阅者，触发相应监听回调

- 下边例子是不会触发视图更新的

```javascript
        <template>
          {{ obj.a }}
        </template>
        export default {
          data() {
            return  {
              obj:{}
            }
          },
          mounted() {
            this.obj.a = 5;
          }
        }
```
- 解决方案
```

```

## 性能优化

### 1.说一下图片的懒加载和预加载.

> - 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
> - 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

## 动手题

### 1.已知如下数组，编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组.

```javascript
var arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];

// 使用 Set 方法去重，flat(Infinity)扁平化
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
  return a - b;
});
//[1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```
