<!-- 每天一个知识点 -->

## HTML

## CSS

### 1. visibility=hidden, opacity=0，display:none 区别？

> opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些 事件，如 click 事件，那么点击该区域，也能触发点击事件的 visibility=hidden，该元素 隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 display=none， 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。

### 2. CSS 中 link 和@import 的区别是什么？

> - `link`属于 HTML 标签，而`@import`是 CSS 提供的
> - 页面被加载的时，`link`会同时被加载，而`@import`被引用的 CSS 会等到引用它的 CSS 文件被加
>   载完再加载
> - `import`只在 IE5 以上才能识别，而`link`是 HTML 标签，无兼容问题
> - `link`方式的样式的权重 高于`@import`的权重

## JS

### 1.箭头函数和 function 的区别.

> 箭头函数根本就没有绑定自己的 `this`，在箭头函数中调用 `this` 时，仅仅是简单的沿着作 用域链向上寻找，找到最近的一个 `this` 拿来使用

### 2.什么是防抖和节流？有什么区别？如何实现？

> 函数防抖(`debounce`):在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。（函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。）

```javascript
function debounce(fun, delay) {
  return function (args) {
    let that = this;
    let _args = args;
    clearTimeout(fun.id);
    fun.id = setTimeout(function () {
      fun.call(that, _args);
    }, delay);
  };
}
```

> 函数节流(`throttle`)：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。（函数节流就是 `fps` 游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。）

```javascript
function throttle(fun, delay) {
  let last, deferTimer;
  return function (args) {
    let that = this;
    let _args = arguments;
    let now = +new Date();
    if (last && now < last + delay) {
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        fun.apply(that, _args);
      }, delay);
    } else {
      last = now;
      fun.apply(that, _args);
    }
  };
}
```

> - 使用场景：
>
> > - `debounce`
>
> > > - `search` 搜索联想，用户在不断输入值时，用防抖来节约请求资源。
> > >
> > > - `window` 触发 `resize` 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
> >
> > - `throttle`
>
> > > - 鼠标不断点击触发，`mousedown`(单位时间内只触发一次)
> > > - 监听滚动事件，比如是否滑到底部自动加载更多，用 `throttle` 来判断

### 3.['1', '2', '3'].map(parseInt) what & why ?

> 第一眼看到这个题目的时候，脑海跳出的答案是 `[1, 2, 3]`，但是真正的答案是`[1, NaN, NaN]`。 首先让我们回顾一下，`map` 函数的第一个参数 `callback`。这个 `callback` 一共可以 接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该 元素的索引。 `arr.map(callback: (value: T, index: number, array: T[]) => U, thisArg?: any)` 而 `parseInt` 则是用来解析字符串的，使字符串成为指定基数的整数。接收两个 参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。 `parseInt(string, radix)` 了解这两个函数后，我们可以模拟一下运行情况 `parseInt('1', 0) //radix` 为 `0` 时，且 `string` 参数不以 `0x` 和 `0` 开头时， 按照 `10` 为基数处理。这个时候返回 `1parseInt('2', 1)` //基数为 1（1 进制）表示的数中，最大值小于 `2`，所以无法解析，返回 `NaNparseInt('3', 2) //基数 为 2（2 进制）`表示的数中，最大值小于 3，所以无法解析，返回 `NaN`

### 4.[Object.is()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 与原来的比较操作符 “===”、“==” 的区别？

> - 两等号判等，会在比较时进行类型转换；
> - 三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回`false`）；
> - `Object.is` 在三等号判等的基础上特别处理了 `NaN `、`-0 `和 `+0 `，保证 `-0` 和 `+0` 不再相同，但
>   `Object.is(NaN, NaN)` 会返回 `true`;
> - `Object.is` 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。

### 5.JS 的 [new](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new) 操作符做了哪些事情

> `new` 操作符新建了一个空对象，这个对象原型指向构造函数的 `prototype`，执行构造函数 后返回这个对象。

### 6. 说一下什么是 virtual dom

> 用 `JavaScript` 对象结构表示 `DOM `树的结构；然后用这个树构建一个真正的 `DOM` 树， 插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树 进行比较，记录两棵树差异 把所记录的差异应用到所构建的真正的 `DOM` 树上，视图就 更新了。`Virtual DOM` 本质上就是在 `JS` 和 `DOM` 之间做了一个缓存。

## 框架

### 框架对比

#### 1. props 在[Vue](https://cn.vuejs.org/)、[React](https://zh-hans.reactjs.org/)中的区别？

> - `vue`中的`props`支持传递静态或动态`props`，静态`props`一般传递字符串。
> - `react`中的`props`是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的`props`来重新渲染子组件，否则子组件的`props`以及展现形式不会改变。

### VUE

#### 1.为什么要在列表组件中写 key，其作用是什么？

> `key` 是给每一个 `vnode` 的唯一 `id`,可以依靠 `key`,更准确,更快的拿到 `oldVnode` 中对 应的 `vnode` 节点

#### 2.v-if 和 v-show 使用场景

> - `v-if` 是惰性的条件渲染，直到渲染条件为真时才渲染内容。
> - `v-show` 会先把内容渲染出来，基于 `css` 的 `display` 属性进行切换

#### 3.computed 和 watch 区分使用场景。

> - `Computed` 是计算属性，依赖其他属性值，且有缓存，只有当他依赖的属性值发生变化时，下一次获取 `computed` 值时才会重新计算。适用于数据计算。
> - `Watch` 是数据的监听回调，当数据变化时会执行回调。适用于数据变化时执行异步操作或开销较大的操作。

#### 4.data 为什么是一个方法而不是对象？

> 因为组件可能被复用为多个实例，如果是对象，那么所有实例会共享一份 data，显然是不行的。而 funtion 会开辟一份独立的内存空间，实例之间不会互相影响。

#### 5.Vuex 持久化？

> - 存放在 `localStorage` 或者 `sessionStorage` 里面，进入页面时判断是否丢失，丢失再去 `localStorage` 或者 `sessionStorage` 里面取；
> - 在 `app.vue` 根组件的 `created` 里面判断是否丢失，在进行上面的操作；

#### 6.说一下什么是 Vue 中的数据双向绑定，以及原理.

> - `vue`是一个 mvvm 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是 vue 的精髓之处了。**值得注意的是，**我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到数据双向绑定。
> - 原理
>   > - `vue` 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 `Object.defineProperty()` 来劫持各个属性的 `setter`，`getter`，在数据变动时发布消息给订阅者，触发相应监听回调

- 下边例子是不会触发视图更新的

```javascript
        <template>
          {{ obj.a }}
        </template>
        export default {
          data() {
            return  {
              obj:{}
            }
          },
          mounted() {
            this.obj.a = 5;
          }
        }
```

> - 可以使用 [Vue.set()](https://cn.vuejs.org/v2/api/#Vue-set) 解决这个问题

#### 8. Vue 中[$route](https://v3.router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1)和[$router](https://v3.router.vuejs.org/zh/api/#router-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7)的区别？

> - `$route` 是“路由信息对象”，包括 `path`，`params`，`hash`，`query`，`fullPath`，`matched`，`name` 等
>   路由信息参数。
> - `$router`是“路由实例”对象包括了路由的跳转方法，钩子函数等。

#### 9. Vue 中 [mixins](https://cn.vuejs.org/v2/api/#mixins)是什么，有什么应用场景？

> - `Mixin`是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问 `mixin` 类的方法而不必成为其子类
> - `Mixin`类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂

> 使用场景：在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立
> 这时，可以通过 `Vue` 的 `mixin` 功能将相同或者相似的代码提出来

示例：

定义一个 `modal` 弹窗组件，内部通过 isShowing 来控制显示

```javascript
const Modal = {
  template: "#modal",
  data() {
    return {
      isShowing: false,
    };
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    },
  },
};
```

定义一个 `tooltip` 提示框，内部通过 isShowing 来控制显示

```javascript
const Tooltip = {
  template: "#tooltip",
  data() {
    return {
      isShowing: false,
    };
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    },
  },
};
```

通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候 `mixin` 就派上用场了

首先抽出共同代码，编写一个 `mixin`

```javascript
const toggle = {
  data() {
    return {
      isShowing: false,
    };
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    },
  },
};
```

两个组件在使用上，只需要引入 mixin

```javascript
const Modal = {
  template: "#modal",
  mixins: [toggle],
};

const Tooltip = {
  template: "#tooltip",
  mixins: [toggle],
};
```

更详细内容可以[查看](https://vue3js.cn/interview/vue/mixin.html#%E4%B8%80%E3%80%81mixin%E6%98%AF%E4%BB%80%E4%B9%88)

#### 10.Vue 的 [slot](https://cn.vuejs.org/v2/guide/components-slots.htmlhttps://cn.vuejs.org/v2/api/#slot) 是什么? 什么时间用?

> 定义：`Slot` 通俗的理解就是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中 `slot` 位置）并且可以作为承载分发内容的出口

> 插槽 `prop` 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 `prop` 渲染出不同的内容。 这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。

具体内容信息可以[查看](https://cn.vuejs.org/v2/guide/components-slots.html)

#### 11.Vue 的优点是什么？

> - 低耦合。视图`（View）`可以独立于 `Model` 变化和修改，一个 `ViewModel` 可以绑定到不同的 `View` 上，当 `View` 变化的时候 `Model` 可以不变，当 `Model` 变化的时候View也可以不变
> - 可重用性。你可以把一些视图逻辑放在一个 `ViewModel` 里面，让很多 `view` 重用这段视图逻辑
> - 可测试。界面素来是比较难于测试的，而现在测试可以针对 `ViewModel` 来写

#### 12.[ref](https://cn.vuejs.org/v2/api/#ref) 的作用.

示例：

```javascript
<template>
  <div class="wrap" ref="wrap"></div>
</template>

<script >
  export default {
    data() {
      name:'wrap'
    },
    methods: {
      getName() {
        console.log(this.name)
      }
    }
  } 
</script>

```

> - 获取 `dom` 元素 `this.$refs.wrap`
> - 获取子组件中的 `data this.$refs.wrap.name`
> - 调用子组件中的方法 `this.$refs.wrap.getName() `

## 性能优化

### 1.说一下图片的懒加载和预加载.

> - 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
> - 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

### 2. 什么是按需加载?

> 当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言，包 括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更 改等。加载的文件，可以是 JS、图片、CSS、HTML 等。

## 动手题

### 1.已知如下数组，编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组.

```javascript
var arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];

// 使用 Set 方法去重，flat(Infinity)扁平化
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
  return a - b;
});
//[1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

## 工具

### webpack

#### 1. [webpack](https://www.webpackjs.com/concepts/) 用来干什么的

> `webpack` 是一个现代 `JavaScript` 应用程序的静态模块打包器(`module bundler`)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(`dependency graph`)，其中包 含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 `bundle`。
